package com.example.aademo.widget;import android.annotation.SuppressLint;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.RectF;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.os.Bundle;import android.os.Parcelable;import android.util.AttributeSet;import android.view.View;import com.example.aademo.R;@SuppressLint("DrawAllocation")public class CircleProgressBarlarge extends View {	private static final String TAG = CircleProgressBarlarge.class.getSimpleName();	private static final String INSTANCE_STATE_SAVEDSTATE = "saved_state";	private static final String INSTANCE_STATE_PROGRESS = "progress";	private static final String INSTANCE_STATE_PROGRESS_BACKGROUND_COLOR = "progress_background_color";	private static final String INSTANCE_STATE_PROGRESS_COLOR = "progress_color";	private boolean mIsInitializing = true;	private Paint mBackgroundColorPaint = new Paint();	private int mCircleStrokeWidth = 10;	private int mCircleBackgroundWidth = 10;	private final RectF mCircleBounds = new RectF();	private float mRadius;	private int mProgressColor;	private Paint mProgressColorPaint;	private int mProgressBackgroundColor;	private float mProgress = 0.3f;	private boolean mOverrdraw = false;	private Matrix mMatrix = new Matrix();	private Bitmap mCirclebgBitmap;	private Bitmap mCircleBottomBitmap;	private float roundArc=230;// 100%进度的话一共是220度	private float startArc=155;//进度条起绘点度数	public CircleProgressBarlarge(final Context context) {		this(context, null);	}	/**	 * Instantiates a new holo circular progress bar.	 * 	 * @param context	 *            the context	 * @param attrs	 *            the attrs	 */	public CircleProgressBarlarge(final Context context, final AttributeSet attrs) {		this(context, attrs, R.attr.circularProgressBarStyle);	}	/**	 * Instantiates a new holo circular progress bar.	 * 	 * @param context	 *            the context	 * @param attrs	 *            the attrs	 * @param defStyle	 *            the def style	 */	public CircleProgressBarlarge(final Context context, final AttributeSet attrs, final int defStyle) {		super(context, attrs, defStyle);		// load the styled attributes and set their properties		final TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.HoloCircularProgressBar, defStyle, 0);		setProgressColor(attributes.getColor(R.styleable.HoloCircularProgressBar_progress_color, Color.CYAN));		setProgressBackgroundColor(attributes.getColor(R.styleable.HoloCircularProgressBar_progress_background_color, Color.MAGENTA));		setProgress(attributes.getFloat(R.styleable.HoloCircularProgressBar_progress, 0.0f));		setWheelSize((int) attributes.getDimension(R.styleable.HoloCircularProgressBar_stroke_width, 10));		setBackgroundStockWidth((int) attributes.getDimension(R.styleable.HoloCircularProgressBar_background_width, 10));		Drawable d = attributes.getDrawable(R.styleable.HoloCircularProgressBar_progress_img);		Drawable d2 = attributes.getDrawable(R.styleable.HoloCircularProgressBar_progress_bottom_img);		mRadius= attributes.getDimension(R.styleable.HoloCircularProgressBar_radius, -1f);		attributes.recycle();		if (d != null) {			mCirclebgBitmap = ((BitmapDrawable) d).getBitmap();		} else {			mCirclebgBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.circleprogressbg);		}		if (d2 != null) {			mCircleBottomBitmap = ((BitmapDrawable) d2).getBitmap();		} else {			mCircleBottomBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.circleprogressbottom);		}		if(mRadius==-1){			mRadius=mCirclebgBitmap.getWidth()/4;		}		updateBackgroundColor();		updateProgressColor();		mIsInitializing = false;	}	@Override	protected void onDraw(final Canvas canvas) {		canvas.translate(mCirclebgBitmap.getWidth() / 2, mCirclebgBitmap.getHeight() / 2);		final float progressRotation = getCurrentRotation();		canvas.drawArc(mCircleBounds, 0, 360, false, mBackgroundColorPaint);		canvas.drawArc(mCircleBounds, startArc, mOverrdraw ? roundArc : progressRotation, false, mProgressColorPaint);				canvas.translate(-mCirclebgBitmap.getWidth() / 2, -mCirclebgBitmap.getHeight() / 2);		canvas.drawBitmap(mCirclebgBitmap, mMatrix, mBackgroundColorPaint);				canvas.translate(0, mCirclebgBitmap.getHeight()-mCircleBottomBitmap.getHeight());		canvas.drawBitmap(mCircleBottomBitmap, mMatrix, mBackgroundColorPaint);	}	@Override	protected void onMeasure(final int widthMeasureSpec, final int heightMeasureSpec) {		final int height = mCirclebgBitmap.getHeight();		final int width = mCirclebgBitmap.getWidth();		final int min = Math.min(width, height);		setMeasuredDimension(min, height);		mCircleBounds.set(-mRadius, -mRadius, mRadius, mRadius);	}	@Override	protected void onRestoreInstanceState(final Parcelable state) {		if (state instanceof Bundle) {			final Bundle bundle = (Bundle) state;			setProgress(bundle.getFloat(INSTANCE_STATE_PROGRESS));			final int progressColor = bundle.getInt(INSTANCE_STATE_PROGRESS_COLOR);			if (progressColor != mProgressColor) {				mProgressColor = progressColor;				updateProgressColor();			}			final int progressBackgroundColor = bundle.getInt(INSTANCE_STATE_PROGRESS_BACKGROUND_COLOR);			if (progressBackgroundColor != mProgressBackgroundColor) {				mProgressBackgroundColor = progressBackgroundColor;				updateBackgroundColor();			}			super.onRestoreInstanceState(bundle.getParcelable(INSTANCE_STATE_SAVEDSTATE));			return;		}		super.onRestoreInstanceState(state);	}	@Override	protected Parcelable onSaveInstanceState() {		final Bundle bundle = new Bundle();		bundle.putParcelable(INSTANCE_STATE_SAVEDSTATE, super.onSaveInstanceState());		bundle.putFloat(INSTANCE_STATE_PROGRESS, mProgress);		bundle.putInt(INSTANCE_STATE_PROGRESS_COLOR, mProgressColor);		bundle.putInt(INSTANCE_STATE_PROGRESS_BACKGROUND_COLOR, mProgressBackgroundColor);		return bundle;	}	private float getCurrentRotation() {//		360 * mProgress;  //如果是完整的圆就是360		return roundArc*mProgress;	}	private void setWheelSize(final int dimension) {		mCircleStrokeWidth = dimension;	}	private void setBackgroundStockWidth(final int dimension) {		mCircleBackgroundWidth = dimension;	}	private void updateBackgroundColor() {		mBackgroundColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);		mBackgroundColorPaint.setColor(mProgressBackgroundColor);		mBackgroundColorPaint.setStyle(Paint.Style.STROKE);		mBackgroundColorPaint.setStrokeWidth(mCircleBackgroundWidth);		invalidate();	}	private void updateProgressColor() {		mProgressColorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);		mProgressColorPaint.setColor(mProgressColor);		mProgressColorPaint.setStyle(Paint.Style.STROKE);		mProgressColorPaint.setStrokeWidth(mCircleStrokeWidth);		mProgressColorPaint.setStrokeCap(Paint.Cap.BUTT);		invalidate();	}	public float getProgress() {		return mProgress;	}	public int getProgressColor() {		return mProgressColor;	}	public void setProgress(final float progress) {		if (progress == mProgress) {			return;		}		if (progress == 1) {			mOverrdraw = false;			mProgress = 1;		} else {			if (progress >= 1) {				mOverrdraw = true;			} else {				mOverrdraw = false;			}			mProgress = progress % 1.0f;		}		if (!mIsInitializing) {			invalidate();		}	}	public void setProgressBackgroundColor(final int color) {		mProgressBackgroundColor = color;		updateBackgroundColor();	}	public void setProgressColor(final int color) {		mProgressColor = color;		updateProgressColor();	}}